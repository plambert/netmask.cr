{"repository_name":"netmask.cr","body":"# netmask\n\nA Crystal library for working with IPv4 and IPv6 CIDR network masks. Easily check if IP addresses belong to specific network ranges.\n\nDocumentation is published to [plambert.github.io/netmask.cr](https://plambert.github.io/netmask.cr/)\n\n## Artificial Intelligence / LLM Contribution\n\nThis library was written by Claude Code using the Sonnet 4.5 model.  The resulting code was manually reviewed by the author listed below.  This was work that the author is entirely capable of having performed personally however it was a fun exercise in learning how to use Claude Code, and the author plans to support the library without the use of such tools in the future, except for advisory usage such as auto-completion and pointing out possible gaps in testing, etc.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     netmask:\n       github: plambert/netmask.cr\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"netmask\"\n\n# Create netmasks from CIDR notation\nipv4_net = Netmask.new \"192.168.0.0/24\"\nipv6_net = Netmask.new \"3fff::/20\"\n\n# Create from hostname (resolves via DNS)\nhost_net = Netmask.new \"example.host.name/32\"\n\n# Create from Socket::IPAddress\nip = Socket::IPAddress.new \"192.168.1.0\", 0\nnet = Netmask.new ip, 24 \n\n# Check if addresses match the network\nipv4_net.matches? \"192.168.0.100\"   # => true\nipv4_net.matches? \"192.168.1.100\"   # => false\n\n# Works with IPv6\nipv6_net.matches? \"3fff::1\"         # => true\nipv6_net.matches? \"fe80::1\"         # => false\n\n# Multiple input types supported\nipv4_net.matches? 0xC0A80064_u32    # UInt32 (IPv4)\nipv6_net.matches? 0x3fff0000000000000000000000000001_u128   # UInt128 (IPv6)\n\n# Byte arrays\nipv4_net.matches? StaticArray[192_u8, 168_u8, 0_u8, 100_u8] \nipv6_net.matches? StaticArray[0x3fff_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 1_u16] \n\n# Slices\nipv4_net.matches? Slice[192_u8, 168_u8, 0_u8, 100_u8] \nipv6_net.matches? Slice[0x3fff_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 1_u16] \n\n# Socket::IPAddress (port is ignored)\nip_addr = Socket::IPAddress.new(\"192.168.0.50\", 8080)\nipv4_net.matches? ip_addr   # => true\n\n# Check network type\nipv4_net.ipv4?  # => true\nipv4_net.ipv6?  # => false\n```\n\n## Supported Input Types for matches?\n\nThe `matches?` method accepts addresses in multiple formats:\n\n- **String**: IPv4 (`\"192.168.1.73\"`) or IPv6 (`\"fe80::1062:2bf2:ae43:2c71\"`)\n- **Socket::IPAddress**: Extracts IP and ignores port\n- **UInt32**: IPv4 address in network byte order\n- **UInt128**: IPv6 address in network byte order\n- **StaticArray(UInt8, 4)**: IPv4 as 4 bytes\n- **StaticArray(UInt16, 8)**: IPv6 as 8 16-bit segments\n- **Slice(UInt8)**: IPv4 (size 4) or IPv6 (size 16) as bytes\n- **Slice(UInt16)**: IPv6 as 8 16-bit segments (size 8)\n\n## Development\n\nRun tests:\n```bash\ncrystal spec -v --error-trace\n```\n\nFormat code:\n```bash\ncrystal tool format src/ spec/\n```\n\nRun linter:\n```bash\nameba -f json src/ spec/\n```\n\n## Contributing\n\n1. Fork it (<https://github.com/plambert/netmask.cr/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Paul M. Lambert](https://github.com/plambert) - creator and maintainer\n","program":{"html_id":"netmask.cr/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"locations":[],"repository_name":"netmask.cr","program":true,"enum":false,"alias":false,"const":false,"types":[{"html_id":"netmask.cr/Netmask","path":"Netmask.html","kind":"struct","full_name":"Netmask","name":"Netmask","abstract":false,"superclass":{"html_id":"netmask.cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"netmask.cr/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"netmask.cr/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"netmask.cr/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/netmask.cr","line_number":87,"url":"https://plambert.github.io/netmask.cr/"}],"repository_name":"netmask.cr","program":false,"enum":false,"alias":false,"const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"{{ (system(\"/Users/plambert/Documents/src/netmask.cr/src/../tools/get-version.sh\")).stringify }}","doc":"VERSION = \"0.1.0\"","summary":"<p>VERSION = &quot;0.1.0&quot;</p>"}],"doc":"A `Netmask` represents an IPv4 or IPv6 CIDR network block.\n\nA `Netmask` is typically created with a CIDR notation string:\n\n```\nipv4 = Netmask.new \"192.168.0.0/24\"\nipv6 = Netmask.new \"fe80::/64\"\n```\n\nIt can also be created from a hostname (which will be resolved via DNS):\n\n```\nhost = Netmask.new \"example.com/32\"\n```\n\nOr from a `Socket::IPAddress` and prefix length:\n\n```\nip = Socket::IPAddress.new \"192.168.1.0\", 0\nnetmask = Netmask.new ip, 24\n```\n\nOnce created, a `Netmask` can test whether IP addresses fall within its range\nusing the `#matches?` method, which accepts addresses in multiple formats:\n\n```\nnetmask = Netmask.new \"192.168.0.0/24\"\n\n# String addresses\nnetmask.matches? \"192.168.0.100\" # => true\nnetmask.matches? \"192.168.1.100\" # => false\n\n# Socket::IPAddress (port is ignored)\nip = Socket::IPAddress.new \"192.168.0.50\", 8080\nnetmask.matches? ip # => true\n\n# Raw integer values (network byte order)\nnetmask.matches? 0xC0A80064_u32 # => true (192.168.0.100)\n\n# Byte arrays\nnetmask.matches? StaticArray[192_u8, 168_u8, 0_u8, 100_u8] # => true\nnetmask.matches? Slice[192_u8, 168_u8, 0_u8, 100_u8]       # => true\n```\n\n## IPv4 and IPv6 Support\n\n`Netmask` uses Crystal's union types to efficiently store either IPv4 or IPv6\nnetwork addresses. The network address is stored internally as either `UInt32`\n(for IPv4) or `UInt128` (for IPv6). The address family is automatically\ndetermined based on the input format.\n\n```\nipv4 = Netmask.new \"10.0.0.0/8\"\nipv4.ipv4? # => true\nipv4.ipv6? # => false\n\nipv6 = Netmask.new \"2001:db8::/32\"\nipv6.ipv4? # => false\nipv6.ipv6? # => true\n```\n\n## Network Mask Application\n\nWhen a `Netmask` is created, the network address is automatically normalized\nby applying the mask. This means host bits are zeroed out:\n\n```\nnetmask = Netmask.new \"192.168.0.100/24\"\nnetmask.matches? \"192.168.0.1\"   # => true\nnetmask.matches? \"192.168.0.254\" # => true\n```\n\n## Address Family Matching\n\nA `Netmask` will only match addresses of the same address family. IPv4 netmasks\nwill not match IPv6 addresses and vice versa:\n\n```\nipv4_net = Netmask.new \"192.168.0.0/24\"\nipv4_net.matches? \"fe80::1\" # => false\n\nipv6_net = Netmask.new \"fe80::/64\"\nipv6_net.matches? \"192.168.0.1\" # => false\n```","summary":"<p>A <code><a href=\"Netmask.html\">Netmask</a></code> represents an IPv4 or IPv6 CIDR network block.</p>","constructors":[{"html_id":"new(ip:Socket::IPAddress,bits:Int32)-class-method","name":"new","doc":"Creates a new `Netmask` from a `Socket::IPAddress` and prefix length.\n\nThe *ip* parameter provides the network address, and *bits* specifies\nthe prefix length (number of leading bits that define the network).\n\nFor IPv4 addresses, *bits* must be between 0 and 32.\nFor IPv6 addresses, *bits* must be between 0 and 128.\n\nThe port number in the `Socket::IPAddress` is ignored:\n\n```\nip = Socket::IPAddress.new \"192.168.1.0\", 8080\nnetmask = Netmask.new ip, 24\nnetmask.matches? \"192.168.1.100\" # => true\n```\n\nWorks with both IPv4 and IPv6:\n\n```\nipv4 = Socket::IPAddress.new \"10.0.0.0\", 0\nnet4 = Netmask.new ipv4, 8\nnet4.matches? \"10.255.255.255\" # => true\n\nipv6 = Socket::IPAddress.new \"fe80::1\", 0\nnet6 = Netmask.new ipv6, 64\nnet6.matches? \"fe80::ffff\" # => true\n```\n\nRaises `ArgumentError` if:\n- The prefix length is negative\n- The prefix length exceeds the maximum for the address family (32 for IPv4, 128 for\n  IPv6)\n- The address family is not IPv4 or IPv6\n\n```\nip = Socket::IPAddress.new \"192.168.0.0\", 0\nNetmask.new ip, 33 # raises ArgumentError\nNetmask.new ip, -1 # raises ArgumentError\n```","summary":"<p>Creates a new <code><a href=\"Netmask.html\">Netmask</a></code> from a <code>Socket::IPAddress</code> and prefix length.</p>","abstract":false,"args":[{"name":"ip","external_name":"ip","restriction":"Socket::IPAddress"},{"name":"bits","external_name":"bits","restriction":"Int32"}],"args_string":"(ip : Socket::IPAddress, bits : Int32)","args_html":"(ip : Socket::IPAddress, bits : Int32)","location":{"filename":"src/netmask.cr","line_number":235,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"new","args":[{"name":"ip","external_name":"ip","restriction":"Socket::IPAddress"},{"name":"bits","external_name":"bits","restriction":"Int32"}],"visibility":"Public","body":"_ = allocate\n_.initialize(ip, bits)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"},"external_var":false},{"html_id":"new(cidr:String)-class-method","name":"new","doc":"Creates a new `Netmask` from a CIDR notation string.\n\nThe *cidr* parameter must be in the format `\"address/prefix_length\"`,\nwhere the address can be:\n- An IPv4 address (e.g., `\"192.168.0.0/24\"`)\n- An IPv6 address (e.g., `\"fe80::/64\"`)\n- A hostname that resolves to an IP address (e.g., `\"example.com/32\"`)\n\nThe prefix length specifies how many leading bits define the network portion.\nFor IPv4, this must be between 0 and 32. For IPv6, this must be between 0 and 128.\n\nThe network address is automatically normalized by applying the mask, so host\nbits in the address portion are ignored:\n\n```\nnetmask = Netmask.new \"192.168.0.100/24\"\nnetmask.matches? \"192.168.0.1\" # => true\n```\n\nIPv6 addresses can use compressed notation:\n\n```\nnetmask = Netmask.new \"fe80::1/64\"\nnetmask.matches? \"fe80::abcd\" # => true\n```\n\nHostnames are resolved via DNS:\n\n```\nnetmask = Netmask.new \"localhost/32\"\nnetmask.matches? \"127.0.0.1\" # => true\n```\n\nRaises `ArgumentError` if:\n- The string is not in valid CIDR notation (must contain exactly one `/`)\n- The address cannot be parsed or resolved\n- The prefix length is out of range for the address family\n\n```\nNetmask.new \"192.168.0.0/33\" # raises ArgumentError (IPv4 max is /32)\nNetmask.new \"192.168.0.0\"    # raises ArgumentError (missing prefix)\nNetmask.new \"invalid/24\"     # raises ArgumentError (cannot resolve)\n```","summary":"<p>Creates a new <code><a href=\"Netmask.html\">Netmask</a></code> from a CIDR notation string.</p>","abstract":false,"args":[{"name":"cidr","external_name":"cidr","restriction":"String"}],"args_string":"(cidr : String)","args_html":"(cidr : String)","location":{"filename":"src/netmask.cr","line_number":137,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"new","args":[{"name":"cidr","external_name":"cidr","restriction":"String"}],"visibility":"Public","body":"_ = allocate\n_.initialize(cidr)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"},"external_var":false}],"instance_methods":[{"html_id":"ipv4?:Bool-instance-method","name":"ipv4?","doc":"Returns `true` if this netmask represents an IPv4 network, `false` otherwise.\n\n```\nipv4 = Netmask.new \"192.168.0.0/24\"\nipv4.ipv4? # => true\n\nipv6 = Netmask.new \"fe80::/64\"\nipv6.ipv4? # => false\n```","summary":"<p>Returns <code>true</code> if this netmask represents an IPv4 network, <code>false</code> otherwise.</p>","abstract":false,"location":{"filename":"src/netmask.cr","line_number":285,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"ipv4?","return_type":"Bool","visibility":"Public","body":"case @network\nin UInt32\n  true\nin UInt128\n  false\nend"},"external_var":false},{"html_id":"ipv6?:Bool-instance-method","name":"ipv6?","doc":"Returns `true` if this netmask represents an IPv6 network, `false` otherwise.\n\n```\nipv6 = Netmask.new \"fe80::/64\"\nipv6.ipv6? # => true\n\nipv4 = Netmask.new \"192.168.0.0/24\"\nipv4.ipv6? # => false\n```","summary":"<p>Returns <code>true</code> if this netmask represents an IPv6 network, <code>false</code> otherwise.</p>","abstract":false,"location":{"filename":"src/netmask.cr","line_number":303,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"ipv6?","return_type":"Bool","visibility":"Public","body":"!ipv4?"},"external_var":false},{"html_id":"matches?(address:String):Bool-instance-method","name":"matches?","doc":"Returns `true` if the given string *address* falls within this network block.\n\nThe *address* can be an IPv4 address (e.g., `\"192.168.0.1\"`) or an IPv6\naddress (e.g., `\"fe80::1\"`). IPv6 addresses can use compressed notation.\n\nReturns `false` if:\n- The address is not within the network range\n- The address is invalid or cannot be parsed\n- The address family doesn't match the netmask's family\n\n```\nnetmask = Netmask.new \"192.168.0.0/24\"\nnetmask.matches? \"192.168.0.1\"   # => true\nnetmask.matches? \"192.168.0.254\" # => true\nnetmask.matches? \"192.168.1.1\"   # => false\nnetmask.matches? \"invalid\"       # => false\nnetmask.matches? \"fe80::1\"       # => false (wrong family)\n```\n\nIPv6 example:\n\n```\nnetmask = Netmask.new \"fe80::/64\"\nnetmask.matches? \"fe80::1\"         # => true\nnetmask.matches? \"fe80::ffff:ffff\" # => true\nnetmask.matches? \"fe81::1\"         # => false\n```","summary":"<p>Returns <code>true</code> if the given string <em>address</em> falls within this network block.</p>","abstract":false,"args":[{"name":"address","external_name":"address","restriction":"String"}],"args_string":"(address : String) : Bool","args_html":"(address : String) : Bool","location":{"filename":"src/netmask.cr","line_number":334,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"matches?","args":[{"name":"address","external_name":"address","restriction":"String"}],"return_type":"Bool","visibility":"Public","body":"begin\n  test_addr = address.includes?(':') ? \"[#{address}]\" : address\n  ip = Socket::IPAddress.parse(\"ip://#{test_addr}:0\")\n  matches?(ip)\nrescue\n  false\nend"},"external_var":false},{"html_id":"matches?(address:Socket::IPAddress):Bool-instance-method","name":"matches?","doc":"Returns `true` if the given `Socket::IPAddress` falls within this network block.\n\nThe port number in *address* is ignored; only the IP address is used for matching.\n\nReturns `false` if the address is not within the network range or if the\naddress family doesn't match the netmask's family.\n\n```\nnetmask = Netmask.new \"192.168.0.0/24\"\nip = Socket::IPAddress.new \"192.168.0.100\", 8080\nnetmask.matches? ip # => true (port 8080 is ignored)\n\nip2 = Socket::IPAddress.new \"10.0.0.1\", 80\nnetmask.matches? ip2 # => false\n```\n\nRaises `ArgumentError` if the address family is not IPv4 or IPv6:\n\n```\n# Assuming a hypothetical unsupported address type\nnetmask.matches? unsupported_addr # raises ArgumentError\n```","summary":"<p>Returns <code>true</code> if the given <code>Socket::IPAddress</code> falls within this network block.</p>","abstract":false,"args":[{"name":"address","external_name":"address","restriction":"Socket::IPAddress"}],"args_string":"(address : Socket::IPAddress) : Bool","args_html":"(address : Socket::IPAddress) : Bool","location":{"filename":"src/netmask.cr","line_number":365,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"matches?","args":[{"name":"address","external_name":"address","restriction":"Socket::IPAddress"}],"return_type":"Bool","visibility":"Public","body":"case address.family\nwhen Socket::Family::INET\n  if ipv4?\n  else\n    return false\n  end\n  octets = (address.address.split('.')).map(&.to_u8)\n  addr_u32 = (((octets[0].to_u32 << 24) | (octets[1].to_u32 << 16)) | (octets[2].to_u32 << 8)) | octets[3].to_u32\n  matches?(addr_u32)\nwhen Socket::Family::INET6\n  if ipv6?\n  else\n    return false\n  end\n  matches?(parse_ipv6(address.address))\nelse\n  raise(ArgumentError.new(\"Unsupported address family: #{address.family}\"))\nend"},"external_var":false},{"html_id":"matches?(address:UInt32):Bool-instance-method","name":"matches?","doc":"Returns `true` if the given `UInt32` *address* (in network byte order) falls within\nthis network block.\n\nThis overload is only valid for IPv4 netmasks. Returns `false` if called on an IPv6\nnetmask.\n\nThe address must be in network byte order (big-endian), with the most significant\nbyte representing the first octet:\n\n```\nnetmask = Netmask.new \"192.168.0.0/24\"\n# 192.168.0.100 = 0xC0A80064\nnetmask.matches? 0xC0A80064_u32 # => true\nnetmask.matches? 0xC0A80164_u32 # => false (192.168.1.100)\n```\n\nReturns `false` when called on an IPv6 netmask:\n\n```\nipv6_net = Netmask.new \"fe80::/64\"\nipv6_net.matches? 0xC0A80064_u32 # => false\n```","summary":"<p>Returns <code>true</code> if the given <code>UInt32</code> <em>address</em> (in network byte order) falls within this network block.</p>","abstract":false,"args":[{"name":"address","external_name":"address","restriction":"UInt32"}],"args_string":"(address : UInt32) : Bool","args_html":"(address : UInt32) : Bool","location":{"filename":"src/netmask.cr","line_number":403,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"matches?","args":[{"name":"address","external_name":"address","restriction":"UInt32"}],"return_type":"Bool","visibility":"Public","body":"if ipv4?\nelse\n  return false\nend\nmasked = apply_mask_ipv4(address)\nmasked == @network\n"},"external_var":false},{"html_id":"matches?(address:UInt128):Bool-instance-method","name":"matches?","doc":"Returns `true` if the given `UInt128` *address* (in network byte order) falls within\nthis network block.\n\nThis overload is only valid for IPv6 netmasks. Returns `false` if called on an IPv4\nnetmask.\n\nThe address must be in network byte order (big-endian):\n\n```\nnetmask = Netmask.new \"fe80::/64\"\n# fe80::1 = 0xfe800000000000000000000000000001\nnetmask.matches? 0xfe800000000000000000000000000001_u128 # => true\nnetmask.matches? 0xfe810000000000000000000000000001_u128 # => false\n```\n\nReturns `false` when called on an IPv4 netmask:\n\n```\nipv4_net = Netmask.new \"192.168.0.0/24\"\nipv4_net.matches? 0xfe800000000000000000000000000001_u128 # => false\n```","summary":"<p>Returns <code>true</code> if the given <code>UInt128</code> <em>address</em> (in network byte order) falls within this network block.</p>","abstract":false,"args":[{"name":"address","external_name":"address","restriction":"UInt128"}],"args_string":"(address : UInt128) : Bool","args_html":"(address : UInt128) : Bool","location":{"filename":"src/netmask.cr","line_number":430,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"matches?","args":[{"name":"address","external_name":"address","restriction":"UInt128"}],"return_type":"Bool","visibility":"Public","body":"if ipv6?\nelse\n  return false\nend\nmasked = apply_mask_ipv6(address)\nmasked == @network\n"},"external_var":false},{"html_id":"matches?(address:StaticArray(UInt8,4)):Bool-instance-method","name":"matches?","doc":"Returns `true` if the given byte array *address* (IPv4 in network byte order) falls\nwithin this network block.\n\nThis overload is only valid for IPv4 netmasks. Returns `false` if called on an IPv6\nnetmask.\n\nThe array must contain exactly 4 bytes representing the IPv4 address in network byte\norder:\n\n```\nnetmask = Netmask.new \"192.168.0.0/24\"\naddr = StaticArray[192_u8, 168_u8, 0_u8, 100_u8]\nnetmask.matches? addr # => true\n\naddr2 = StaticArray[192_u8, 168_u8, 1_u8, 100_u8]\nnetmask.matches? addr2 # => false\n```","summary":"<p>Returns <code>true</code> if the given byte array <em>address</em> (IPv4 in network byte order) falls within this network block.</p>","abstract":false,"args":[{"name":"address","external_name":"address","restriction":"StaticArray(UInt8, 4)"}],"args_string":"(address : StaticArray(UInt8, 4)) : Bool","args_html":"(address : StaticArray(UInt8, <span class=\"n\">4</span>)) : Bool","location":{"filename":"src/netmask.cr","line_number":453,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"matches?","args":[{"name":"address","external_name":"address","restriction":"StaticArray(UInt8, 4)"}],"return_type":"Bool","visibility":"Public","body":"if ipv4?\nelse\n  return false\nend\naddr_u32 = (((address[0].to_u32 << 24) | (address[1].to_u32 << 16)) | (address[2].to_u32 << 8)) | address[3].to_u32\nmatches?(addr_u32)\n"},"external_var":false},{"html_id":"matches?(address:StaticArray(UInt16,8)):Bool-instance-method","name":"matches?","doc":"Returns `true` if the given segment array *address* (IPv6 in network byte order) falls\nwithin this network block.\n\nThis overload is only valid for IPv6 netmasks. Returns `false` if called on an IPv4\nnetmask.\n\nThe array must contain exactly 8 16-bit segments representing the IPv6 address in\nnetwork byte order:\n\n```\nnetmask = Netmask.new \"fe80::/64\"\n# fe80::1\naddr = StaticArray[0xfe80_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 1_u16]\nnetmask.matches? addr # => true\n\n# fe81::1\naddr2 = StaticArray[0xfe81_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 1_u16]\nnetmask.matches? addr2 # => false\n```","summary":"<p>Returns <code>true</code> if the given segment array <em>address</em> (IPv6 in network byte order) falls within this network block.</p>","abstract":false,"args":[{"name":"address","external_name":"address","restriction":"StaticArray(UInt16, 8)"}],"args_string":"(address : StaticArray(UInt16, 8)) : Bool","args_html":"(address : StaticArray(UInt16, <span class=\"n\">8</span>)) : Bool","location":{"filename":"src/netmask.cr","line_number":479,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"matches?","args":[{"name":"address","external_name":"address","restriction":"StaticArray(UInt16, 8)"}],"return_type":"Bool","visibility":"Public","body":"if ipv6?\nelse\n  return false\nend\naddr_u128 = 0_u128\naddress.each_with_index do |segment, i|\n  addr_u128 = addr_u128 | (segment.to_u128 << (112 - (i * 16)))\nend\nmatches?(addr_u128)\n"},"external_var":false},{"html_id":"matches?(address:Slice(UInt8)):Bool-instance-method","name":"matches?","doc":"Returns `true` if the given byte slice *address* (in network byte order) falls within\nthis network block.\n\nThe slice size determines the address family:\n- Size 4: Interpreted as IPv4 address (only matches IPv4 netmasks)\n- Size 16: Interpreted as IPv6 address (only matches IPv6 netmasks)\n\n```\nipv4_net = Netmask.new \"192.168.0.0/24\"\nipv4_bytes = Slice[192_u8, 168_u8, 0_u8, 100_u8]\nipv4_net.matches? ipv4_bytes # => true\n\nipv6_net = Netmask.new \"fe80::/64\"\nipv6_bytes = Slice[0xfe_u8, 0x80_u8, 0_u8, 0_u8, 0_u8, 0_u8, 0_u8, 0_u8,\n  0_u8, 0_u8, 0_u8, 0_u8, 0_u8, 0_u8, 0_u8, 1_u8]\nipv6_net.matches? ipv6_bytes # => true\n```\n\nRaises `ArgumentError` if the slice size is not 4 or 16:\n\n```\nnetmask = Netmask.new \"192.168.0.0/24\"\nbad_slice = Slice[192_u8, 168_u8] # only 2 bytes\nnetmask.matches? bad_slice        # raises ArgumentError\n```","summary":"<p>Returns <code>true</code> if the given byte slice <em>address</em> (in network byte order) falls within this network block.</p>","abstract":false,"args":[{"name":"address","external_name":"address","restriction":"Slice(UInt8)"}],"args_string":"(address : Slice(UInt8)) : Bool","args_html":"(address : Slice(UInt8)) : Bool","location":{"filename":"src/netmask.cr","line_number":513,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"matches?","args":[{"name":"address","external_name":"address","restriction":"Slice(UInt8)"}],"return_type":"Bool","visibility":"Public","body":"case address.size\nwhen 4\n  if ipv4?\n  else\n    return false\n  end\n  addr_u32 = (((address[0].to_u32 << 24) | (address[1].to_u32 << 16)) | (address[2].to_u32 << 8)) | address[3].to_u32\n  matches?(addr_u32)\nwhen 16\n  if ipv6?\n  else\n    return false\n  end\n  addr_u128 = 0_u128\n  address.each_with_index do |byte, i|\n    addr_u128 = addr_u128 | (byte.to_u128 << (120 - (i * 8)))\n  end\n  matches?(addr_u128)\nelse\n  raise(ArgumentError.new(\"Invalid slice size: #{address.size}, expected 4 or 16\"))\nend"},"external_var":false},{"html_id":"matches?(address:Slice(UInt16)):Bool-instance-method","name":"matches?","doc":"Returns `true` if the given segment slice *address* (IPv6 in network byte order) falls\nwithin this network block.\n\nThis overload is only valid for IPv6 netmasks. Returns `false` if called on an IPv4\nnetmask.\n\nThe slice must contain exactly 8 16-bit segments representing the IPv6 address:\n\n```\nnetmask = Netmask.new \"fe80::/64\"\n# fe80::1\nsegments = Slice[0xfe80_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 0_u16, 1_u16]\nnetmask.matches? segments # => true\n```\n\nRaises `ArgumentError` if the slice size is not 8:\n\n```\nnetmask = Netmask.new \"fe80::/64\"\nbad_slice = Slice[0xfe80_u16, 0_u16, 0_u16, 0_u16] # only 4 segments\nnetmask.matches? bad_slice                         # raises ArgumentError\n```","summary":"<p>Returns <code>true</code> if the given segment slice <em>address</em> (IPv6 in network byte order) falls within this network block.</p>","abstract":false,"args":[{"name":"address","external_name":"address","restriction":"Slice(UInt16)"}],"args_string":"(address : Slice(UInt16)) : Bool","args_html":"(address : Slice(UInt16)) : Bool","location":{"filename":"src/netmask.cr","line_number":554,"url":"https://plambert.github.io/netmask.cr/"},"def":{"name":"matches?","args":[{"name":"address","external_name":"address","restriction":"Slice(UInt16)"}],"return_type":"Bool","visibility":"Public","body":"if address.size != 8\n  raise(ArgumentError.new(\"Invalid slice size: #{address.size}, expected 8\"))\nend\nif ipv6?\nelse\n  return false\nend\naddr_u128 = 0_u128\naddress.each_with_index do |segment, i|\n  addr_u128 = addr_u128 | (segment.to_u128 << (112 - (i * 16)))\nend\nmatches?(addr_u128)\n"},"external_var":false}]}]}}